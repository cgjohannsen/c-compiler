\subsection{Mode 4}
\label{sec:mode-4}

This mode corresponds to the type checker and will output each of the types of
the relevant expressions and function declarations.

\subsubsection{Features}

\begin{itemize}
    \item Parser now returns an Abstract Syntax Tree (AST) corresponding to the input program.
    \item Global and local variable, type, and function declarations are printed.
\end{itemize}

\subsubsection{Implementation Details}

\textbf{Relevant Files:}

\begin{itemize}
    \item \verb|parse/parse.c|: This file was revamped from mode 3 so that it now builds an AST as well as just checking for syntax errors.
    \item \verb|parse/ast.c|: The data structure corresponding to the AST.
    \item \verb|parse/typecheck.c|: This file holds all the functionality for performing type checking of the input file.
\end{itemize}

\noindent \textbf{Relevant Data Structures:}

\begin{itemize}
    \item \verb|astnode_t|: This is a tree structure that serves as the AST of the program. Functionally, the AST is a binary tree where the left child is the child of the current node and the right child is the next sibling. 
\end{itemize}

\noindent \textbf{Working Description:} The type checker essentially traverses
the AST generated by the parser and ensure that the nodes are of valid types.
This reduces to doing a depth first traversal, assigning types to nodes from the
bottom up of the AST.

For expression type checking, the checker does this bottom up traversal in that
each lead node will be a constant or variable that have a specific C type
associated with them. The nodes immediately above these check that the operands
are of valid types (and does widening if need be). Eventually, the overall
expression is assigned a C type according to its root node.

The other functionality that the typechecker has is to ensure that functions
have correct argument types when called. It does this by keeping track of the
functions/variables in the symbol table and checking against those when a
function is called.